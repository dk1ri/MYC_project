MYC Announcements and  Commands
Author: DK1RI
Version V02.8 20161101
This paper is published in  https://github.com/dk1ri as well

Introduction

This paper describes announcements and the command syntax.
For more details of the MYC system please check the reference.

Definitions and formats

see http://dk1ri.de/myc/Definitions.pdf

Announcements

An announcement line uses a readable string in <sm> format. So the number of the command token is a readable figure, 1 eg for a hex &H01 command 
A complete announcement of a device consist of one line with the basic announcement, lines of command announcements, lines for the reserved tokens,  lines of rules and one I-annnouncement; in this sequence.
The basic announcement contains the description of the device. For details see [5]
The command announcements describe the commands the  device will understand.
Two of the reserved tokens are used by the CR to identify a device, also, if more than one of the same device-group (same hardware and firmware) exist. (&H00, &HxxFF)
The rules describe the conditions, when and how the commands will work for a device.
The I-line is inserted by the CR to the full announce-list for each device. It shows some individual parameters of the device, so that RU and SK can identify them in all cases.
Some operating commands have an influence on the status of other commands. This is handled by rules as well.
Rules lines start with "R" and are forwarded to the LD.
“Q” rules are send by the rules-devices to the command-router and are not forwarded. They are used for user management.

Each command belongs to a command-type. Command-types have two letters: the first denotes the operation type, the second the operating object / function
.
Operation type
Active operating is denoted by “o”, requesting an answer by “a”  as the first letter. If a function can operate and answer, the descriptions in the other announcement should be identical. For example a memory, which can be written and read, must have the same unique description, to allow other devices to identify, that it is the same memory. Alternatively the description can be "as5" eg, where 5 is the command-token of the other command (see also announcement / command optimizing below).
The “r” and “s” types is identical to the “o” and “a” type and therefore not mentioned in the list below. These are used by some SK  to denote what they can or want to send. For details see http://dk1ri.de/myc/skin.pdf .
A special form of operate / answer command has the first letter u. It is used with the memory command only (up to now). For details see List of Standardized Command-types below.
Additionally there are some meta-commands as well for system internal usage with operation type “i”.

Operating object / function
Each operating object denotes a general function like “s” for a switch and exactly defines the number and type of the properties. From this other devices will know the details of the devices function and the length of a properties and therefore the length of a command.. The list below show the announcement templates, corresponding command, answer and info for all allowed command-types.
In some cases, different  operating objects can be chosen. A frequency control will obviously get a range “p” type, because it covers a range of values, which can be easily defined with a min and max value. But what about an address ranging from 1  to 10? This can also be realized as a switch with 10 positions or a range type command. The command will act identical; the display on the SK may be different. If the real values are not a range  or each position need an individual label the switch must be used in any case.
A rule of thumb is, that the range, p command-type will be used, if there are "many" equal distance values in a range.
Optional properties are defined for some command-types and are optional for an announcement. If they are defined in an announcement, they must be given in a command as defined.

In general a FU is a very simple construction with limited communication bandwidth. So command communication should be simple and short, but announcements are communicated rarely or never, so they can be longer and descriptive in a readable format.
Announcements are stored in the devices, They are unique to a hardware / firmware combination and will never change. Therefore they can be stored also in a database or with the CR.
The CR may find the details of the attached devices somewhere and probably will not ask the devices for detailed announcements.
The CR, LD, RU should have more computer power. They should be able to build up a complete MYC System by reading the announcements without operator interaction also in a varying environment. To ensure this, the description in the announcement should be sufficient and not too short.  This is valid for for some SK as well. If not – as for simple switches - they can be handled in a special manner.

For security reasons the CR will connect known devices only. So it must know a place, where all "its" possible devices are listed.
May be, that not all devices are active every time, but the CR, LD, RU and SK must be able to handle this situation. So, the answer of a (announcement) &HxxF0 command to a command-router is not static.  It varies, when devices disappear. Commands can also be active or disabled.

All devices must have announcements for the mandatory reserved commands. Additional announcements depend on the device.
All FU and some SK belong to a unique device-group. This device-group has a unique name and has a not changeable set of announcements and firmware.
How announcements can be called by the commands &H00 and  &HxxF0 is described in [5]

General syntax for a command-announcement

<c>;<ct>[,<des>]...[,<des>][<;pa>[,<des>]..[,<des>]]...[;<pa>[,<des>]... [,<des>]]

Commands and properties

The command tokens use numeric byte, word or long format.  The shortest format possible is always used.
For properties the same  rules apply. For memory type commands a string and time format is allowed as property as well.
So if a device has less than 239 (0, 240- 255 is reserved) commands, the communication with the CR use byte format for the command token. If the CR knows more for the different devices, it may communicate with the SK with words (2 bytes). or long (4 bytes). In this case, the first byte of translated command-tokens must not be 0 (but can be 1), because one byte &H00 is reserved for the basic announcement.
Shortest possible format is used for properties as well. The CR, LD,RU and SK know the format by the announcements.
A command consist of a command-token and properties (parameters) depending on the command-type.
The number and type of the properties of a command must match the announcement. If the announcement describe a min and max property and unit, the command will obviously have one property only for the value. For details see List of Standardized Command-types below.

There is no rule for FU for the numbering of the command-token, but simple sequenced numbering is recommended. The CR will put  the command-tokens of the known FU, RU and lower level CR together, so that all commands are sequenced with translated command-tokens in the same order as the original announcement lines. The translated command-tokens start with &H01 (&H0100, &H01000000, (no "0" as first byte) or higher in a simple sequence without gaps. There may be gaps in the list, if a known device disappears. 
The CR will replace other announcement commands (&Hxx240) by “in” , do nothing
The CR will also replace any individualization command by “in”. The own indication is defined by a configuration file.
The CR will include &H00 of other devices into the complete command-list but  answer them by itself.
A announce-list from a lower level CR will have the own (CR)  basic announcements at the beginning and the I-announcement the end. The CR will not change the sequence, so that the hierarchical structure is visible.
The reserved tokens of the individual devices – if forwarded - are translated by the CR as well; the own (reserved) tokens of the CR are &HxxF0 ...

All devices except FU must interact with the CR with translated tokens.
The CR will translate the inline command-tokens of the content of commands and announcements as well.

General syntax for a command

<c>[<p>]...[<p>]

Info

Some  command-types must send answers without a corresponding command as info, some can send  info. Not all devices will send infos in that case.
Infos are not using operating commands.
If a FU will send info, it must send answers with info format as well. See Data transfer in http://dk1ri.de/myc/Description.pdf for explanation.
If a device send infos via a polled interface, it must provide a FIFO type memory for strings with the first command-type description INFOPOLL.
So the CR can ask for infos.
The CR translates the info tokens if necessary. It sends all translated infos to the LD. The LD will send translated  infos to the SK.
It is not decided, weather CR send infos to SK directly.
Infos are not sent to FU.

General syntax for info

<c>[<p>]...[<p>] 			for normal devices.
<c><destination>[<p>]...		for some meta-commands, <destination is the command-token of the basic announcement of the device

Announcement / Command optimizing

The following optimizations may be used by all devices.
The SK should understand the optimizations.

Long announcement lines
If a announcement is too long to fit in one line more lines can be used. The command-token must be the same.
So
	11;aa,Control;a,Preset;a,Motor_cw;a,Motor_ccw;
	11;aa;a,Limit;a,Underlimit;a,Overlimit
is the same as
	11;aa,Control;a,Preset;a,Motor_cw;a,Motor_ccw;a,Limit;a,Underlimit;a,Overlimit
The CR simply paste the lines together omitting command-token and command-type of the second line. Take care on the “;” at the end of the first line.

Save space in announcements
If  a function can operate and answer, one announcement can be simplified:
	5;op,Rotatoroffset;1;361
	6;ap,as5			Nothing else will follow
will be resolved by the CR to
	6;ap,Rotatoroffset;1;361

Optimize command transmission 
If a command should be very short and a parameter should be part of the command-token, the following can be used
Instead of  a the two byte command
	2;os;0,manual;1,preset
you use 2 one byte command-token
	2;os;0,manual
	3;os,ext2;1,preset			ext as extend. The extend is an information for SK, that it is one switch

different method
Some functions can be accessed with different methods. A oscillator can be controlled with a value (by memory or knob) or as scan function
2,op,VFOA;30000 ,{3500000 to 3800000};lin;Hz
3,oo,ext2;255;1;255;1;250;down
4,oo,ext2;255;1;255;100;100;up				fixed stepsize for scanning, stepsize will be omitted in the command 

List of Standardized Command-types

These command-type templates contain a description and format of  the properties, where necessary.

Meta-commands
Meta commands are used to control the system, they do not initiate actions.

commands, which denote, which commands are enabled / disabled :
At start all commands are enabled. To disable commands rules should be used. The oc /oc, od /ad commands are not supported anymore.

info commands:
These command-types have  info only or no data transfer.
Only the LD has the overview over the complete status of the system. It knows, which commands cannot be used and  and will be ignored. It will send this information to SK.
These “i'x'”infos have two strings as parameters:
The first parameter is a string <s> with the command-token of the basic announcements of those devices the info is valid. A "xx0" is used to send to all.  The CR strips this parameter and send the second to the affected devices.
The second parameter is a string the data.


announce:	<c>;ic[,<des>]...[,<des>];max_number_of_addresses<,des>;max_number_of_token<,des>
											enable (0) or disable (1) variable list of commands
command:	-									
answer:	-					
info:		<c>0|1<s><s> 

announce:	<c>;id[,<des>]...[,<des>];max_number_of_addresses;<,des><c><,des>;...<c><,des>
											enable (0) or disable (1)  fixed list of command-tokens
command:	-									
answer:	-					
info:		<c>0|1<s>								<s> is list of addresses

Other metacommands:

no command 
This command can be used as a placeholder or when an announcement is needed only (as for the reserved  &HxxFA command)
announce:	<c>;in<,des>					no command 
announce:	<c>;ix>des>;[...]				x is a operating object; if an announcement only should be transferred.

Switches:
one dimension for normal switches
two dimensional for crosspoint or similar

OPTION for  all switches:
DIMENSION,<number_of_row>,<des>,<number_of_cols>,<des>..			<des> is something like x y z
												info for HI only to display in more than one dimension.
												must be at the end of the announcement
												<number_of_row> are the number of rows, columns...
												Number of positions must match the product of the dimensions
operating commands
announce:	<c>;or[,<des>]...[,<des>];pos0[,<des>]...[;posn,[<des>]][;<OPTION>[,<des>]...	]
												reset (0) or set (1)  posm (number from 0 to n)
												1st <des> for reset, 2nd for set
command:	<c>0|1										simple switch (pos0 in announcement only) <0> must be 													omitted
		<c><n>0|1									reset or set set position <n>

announce:	<c>;os[,<des>]...[,<des>];pos0[,<des>];...posn[.<des>][;<n>,<OPTION>[,<des>]...	]
												set one out of n positions active,  reset other
command:	<c><n>									set position <n>, reset the others

announce:	<c>;ot[,<des>]...[,<des>];[pos0[,<des>];...posn[,<des>][;<n>,<OPTION>[,<des>]...	]
												set one of n positions active toggling one position to the next
												one active at a time, can be an extension of a os command.
command:	<c>

announce:	<c>;ou[,<des>]...[<,des>];pos0[,<des>];...;posn[,<des>][;<n>,<OPTION>[,<des>]...	]
												set one of n positions momentary active
command:	<c>										push button switch,  no command parameter, if there is pos0
 												only 
		<c><n>
answer commands
announce:	<c>;ar[,<des>]...[,<des>];pos0[,<des>].[;posn,[<des>]][;<n>,<OPTION>[,<des>]...	]
												read reset or set of position
command:	<c>										simple switch  (pos0 in announcement only)
		<c><n>									read set or reset of position <n>
answer:	0|1
info:		<c>0|1<n>									<n> omitted if one position only

announce:	<c>;as[,<des>]...[,<des>];pos0[,<des>];...posn[.<des>][;<n>,<OPTION>[,<des>]...	]
												read active position; one out of n 
command:	<c>
answer:	<n>										position <n> is active
info:		<c><n>

announce:	<c>;at[,<des>]...[,<des>];[pos0[,<des>];...posn[,<des>][;<n>,<OPTION>[,<des>]...	]
												read active position; one out of n 
												not used, if this is an extension of a as command
command:	<c>
answer:	<n>										position <n> is active
info:		<c><n>

Announce:	<c>;au,..									for details see operate – answer commands
Range controlled functions
one dimensional form for  potentiometer, frequency generator ...
two dimensional form for joysticks...
three dimensional form for robotics...
<number_of_valuesx> are byte, word or long, not single or double. To display real values with "." see “More about Descriptions”
Sequence of parameters must not be changed.

operating commands  
announce:	<c>;op[,<des>]...;number_of_valuesx,<des>;lin|log,<des>;unitx,<des>;number_of_valuesy,..
												go to value (“0” based!!!)
												number_of_values is of type <n>
												Example (User display is in steps of 10):
											2;op;50001,{3500000 to 3800000,7000000 to 7200000};lin;Hz
												lin|log: real values in <des> linear or logarithmic
												more number_of_values blocks means more than one 													dimension 
command:	<c><n>									go to n 
		<c><n><n>									2 dimensional
comments: The userinterface calculate the real stepsize using the <des> (3500000 to 3800000 + 7000000 to 7100000 eg /  by number_of_values.
The userinterface decides, how accurate the display is. 
If the displayed step would vary with ranges, a additional announcement with ext option can be used.

announce:	<c>;oo,ext<c>,[<des>]...;number_of_steps[,<des>];steptimemin,<des>;steptimemax[,<des>];stepsizemin[,<des>];
														stepsizemax[,<des>];up|down...
												move position stepwise 
												works only as extension of a op command ext<c>
												number_of_steps=0 will stop
												multiple of 6 parameters means more than one dimension 
												dimensions in announcement must match the op commands
												stepsize <  stepsizemiddle means stepdown
												identical values for min and max mean fixed value, command
												and info is transmitted without that value
command:	<c>000									stops	(one dimension) after steptimemin				
		<c>&H02&H01&H08							move 2 times, 8 steps,with steptime 1
												one dimension
		<c>&H02									2 times, fixed steptime and stepsize

announce:	<c>;oq[,ext<c>,<des>]...[<,des>];<defaultpositionx>[,des]...;<defaultpositiony>[,des]....	
												go to default;  works only as extension of a op command
command:	<c>

answer commands
announce:	<c>;ap[,<des>]...;number_of_valuesx,<des>;lin|log,<des>;unitx,<des>;number_of_valuesy,..																		read position
												details see op command 
command:	<c>
answer:	<n>										one dimensional (n is “0” based)
answer:	<n><n><n>									three dimensional
info:		<c><n>									one dimensional

Command has a data destination like memory, data channel or text field

It is not intended to replace data streams with these command, but it is not defined clearly, where simple data transmission ends and streaming is starting.
There is no “undefined” value, when reading a memory. Therefore a FIFO  should not be read if not known whether the data is valid. The device should send the data by info or support a memory with the number of available data.
The content of the memory has the full range of the defined properties: so “0” as first byte is allowed as answer. The position of the memory cell is “0” based as well.

operating commands
announce:	<c>;om[<,des>]...[,<des>]; <ty>[,<des>]... [,<des>];m_cols[,<des>]...[,<des>];[<m_row[,<des>]...[,<des>]]...
												write a memory element of type <ty> with optional restrictions 
												as given in <des> of <ty>
												m_cols, … is the number of columns .. the device can handle
												<des> may be the name of row/col,
												any dimension is possible; 
												position z of a element is x+y*(m_rows)  +...
												fixed type <ty>
command:	<c><z><data>								write to position z

announce:	<c>;on,[,ext<c>]...[,<des>]; <ty>[,<des>]... [,<des>];m_cols[,<des>]...[,<des>];[<m_row[,<des>]...[,<des>]]...
												sequential access mode for memory 
												may work as extension to a om command 
												string s are transmitted with the individual stringlength
command:	<c><n><m><data>								write m elements to memory, starting at position n (“0” based)
												m must not exceed the number of elements
												If end of memory is reached next element is written to n=0

announce:	<c>;of[,<des>]...[,<des>];<m>,<des>;<ty>[,<des>]				FIFO, stack, stream or similar functions for <ty> with optional 												restrictions as given in <des> of  <ty>
												<m> is number of data elements, which can be sent with one 
												command  
												each string is transmitted with its own stringlength
												nothing known about the complete memory size!!!
command:	<c><m><data>								FIFO stack.. send m data to stack

announce:	<c>;oa[,<des>]...[,<des>];<ty>[,<des>]...[;<ty>[,<des>]]			array 	
												types <ty> with optional restrictions 
												as given in <des>;  can be mixed but not with command-token
command:	<c><n><data>								write to array, nth position (“0” based)
												<n> must be omitted for 1 element array.

announce:	<c>;ob[,<des>]...[,<des>];<ty>[,<des>]...[;<ty>[,<des>]]			sequential access mode for memory 
												can work as extension to a oa command 
command:	<c><n><m><data>								write m elements to memory, starting at position n (“0” based)
												m must not exceed the number of elements
												If end of memory is reached next element is written to n=0.

answer commands 
announce:	<c>;am[<,des>]...[,<des>]; <ty>[,<des>]... [,<des>];n_rows[,<des>]...[,<des>];[<n_cols[,<des>]...[,<des>]]...
												m_cols, … is the number of columns .. the device can handle
												position z of a element is x+y*(m_row-1 +...
												fixed type
command:	<c><n>									read position <n> (“0” based)
answer:	<data>
info:		<c><n><data>

announce:	<c>;an[<,des>]...[,<des>]; <ty>[,<des>]... [,<des>];n_rows[,<des>]...[,<des>];[<n_cols[,<des>]...[,<des>]]...
												sequential access mode for memory 
												may work as extension to a am command 	
command:	<c><n><m>									read m elements from memory, start at position n (“0” based)
answer:	<data>	
info:		<c><n><m><data>								If end of memory is reached next element is read from pos1

announce:	<c>;af[,<des>]...[,<des>];<n>,<des>;<ty>[,<des>]				FIFO, stack, stream or similar functions
command:	<c><m>									read m elements
answer:	<data>										pop stack
info:		<c><m><data>								pop stack m times

announce:	<c>,aa[,<des>]...[,<des>];<ty>[,<des>];<ty>[,<des>]...			array	
												OPTION syntax for Individualization command, see [6]
command:	<c><n>									array, n is the nth element (“0” based)
												<n> must be omitted for 1 element array.
answer:	<data>	
info:		<c><n><data>								array, nth element (“0” based)  
			
announce:	<c>;ab[,<des>]...[,<des>];<ty>[,<des>]...[;<ty>[,<des>]...			sequential access mode for memory 
												can work as extension to a aa command 	
command:	<c><n><m>									read m elements from memory, start at position n (“0” based)
answer:	<data>	
info:		<c><n><m><data>								if end of memory is reached next element is read from n=0

use command
announce:	<c>;um,as<c>.as<c>[<,as<c>[,<des>]...					should be used with om commands with <ty>: z. which store
												internal data
												first <c>: corresponding om command
												other <c>: The device will send these answer commands.		
command:	<c><n>									use position <n> (“0” based)
answer:	-
info:		<c><data>...
For explanation of this command see data transfer in http://dk1ri.de/myc/Description.pdf

More about Descriptions

The description should help the SK to find the correct parameters and to do the correct user readable labeling. If there is no description the HI will use the full range as defined by the property type and the labeling will be accordingly.
It can also be used to limit the range of allowed values. Hex Values as &H00 to &H7F are allowed.
The first “part” within the description is used for this; additional description separated by “,” may follow.
The following rules apply for the three types of commands:
Descriptions for switches:
Usually any button of switches has a label. So the first value of the description is used as label. Others, separated by ”,” may follow.

Descriptions for range commands:
To separate the labeling from the other description bracket {} are used.
The number of values is given by the properties. So this labeling information is  necessary only, if the real and transmitted values are different.
999,{1 to 999}			transmitted as 0 to 998
1000,{0.0 to 99.9}			transmitted as 0 to 999
4,{1,3,4,5}				transmitted as 0 to 3
401,{0 to 99, 200 to 500}		transmitted as 0 to 400  (2 byte)
If the labeling for different ranges has different spacing, the following is used:
10,{5{1 to 5},lin,5{10 to 50},lin}	labels are 1 2 3 4 5 10 20 30 40 50
lin is optional in this case

Descriptions for memory type commands:
There are three optional kinds of descriptions. 
The first describe the real values of memory positions for the om, on, am, an commands only, if real values and transmitted values are different. This description come with the row / column property. The transmitted values have the range 0 to x (as given by this type of description), The labeling can use the labels for rows, columns...
This description is enclosed by {}.
If the number of <pa> do not match the <des>, the HI will try some rounding (defined by the HI). This is not recommended.
The following is allowed:
3,{1,2,3}		value 0,1,2 are the real values for 1, 2,3 (3 element memory)
3,{a,b,d}		a, b, d are real values for 0, 1, 2. (3 element memory)
21,{1.0 to 3.0}	real values are 1.0, 1,1... 3.0 for 0 … 20
999,{1 to 999}	real values 1 to 999 for 0 to 998
2,{1,2};2,{3,4}	the label for &H01 could be “2 3”, for &H03: “2 4”

The second type of description describe the allowed values of data and come as first description with <ty>. This is a restriction of the full range of <ty>. For string type values, it is a restriction of the allowed characters, others are transferred “0” based; so it may be a restriction and translation.
In other words: if you want to avoid a translation, you must use a string type. 
This type of description is enclosed by {}
2,{a,c,d}		string of 2 characters; this limits the allowed characters, others will be ignored by the device.
2,{a to z,A to Z}	string of 2 characters; letters only allowed
b,{a,c,d}		byte; stored and transmitted as 0,1,2 Others will be ignored.
w,{0 to 100.0}		word (2 bytes); 0 to 100.0 only, transmitted as 0 to 1000, other numbers are ignored.
The device will ignore commands with values out of range and may produce an error message.

The third type of description separated by “,” can give additional information for the HI.




More about Properties

Positional properties and numeric data are transferred as binary values; lowest value is 0 always.
Because the commandrouter will have to poll some devices, which cannot send answers or info by themselves (with I2C interface eg), the CR must have a indication weather the read data are valid or not. This can be done by the parameter ANSWERTIME of the &HxxFA command. If not given, the time is 100ms. The CR will wait for this time, before reading data. Another method to solve this is to use ADDFF or ADD00. For details see [5].

Copyright

Dieses Dokument darf unverändert kopiert werden.
Die Ideen in diesem Dokument unterliegen der GPL (Gnu Public Licence,V2) soweit keine früheren, anderen Rechte betroffen sind.
Die Verwendung der Unterlagen erfolgt auf eigene Gefahr; es wird keinerlei Garantie übernommen.
This document can be copied without changes.
The ideas of this document can be used under GPL (Gnu Public License, V2) as long as no earlier other rights are affected.
The usage of this document is on own risk, there is no warranty.

Reference

[1]	http://dk1ri.de/myc/MYC.pdf  (german)
[2]	http://dk1ri.de/myc/MYC_en.pdf
[3]	http://dk1ri.de/myc/Description.pdf
[4]	http://dk1ri.de/myc/commands.pdf
[5]	http://dk1ri.de/myc/Reserved_tokens.pdf
[6]	http://dk1ri.de/myc/Rules.pdf
[7]	http://dk1ri.de/myc/commandrouter.pdf
[8]	http://dk1ri.de/myc/Rules_device.pdf
[9]	http://dk1ri.de/myc/skin.pdf
[10]	http://dk1ri.de/myc/logicdevice.pdf
[11]	http://dk1ri.de/myc/Definitions.pdf
