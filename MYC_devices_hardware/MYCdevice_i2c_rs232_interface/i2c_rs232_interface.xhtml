<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">I2C-Rs232_interface</title><meta name="DCTERMS.title" content="I2C-Rs232_interface" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="DK1RI"/><meta name="DCTERMS.issued" content="2012-02-01T18:05:06.26" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="DK1RI"/><meta name="DCTERMS.modified" content="2015-12-27T10:42:18.34" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="MYC," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:12pt; font-family:Times New Roman; writing-mode:page; text-align:right ! important; }
	.P10 { font-size:12pt; font-family:Times New Roman; writing-mode:page; font-weight:normal; }
	.P11 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P3 { font-size:14pt; font-family:Times New Roman; writing-mode:page; text-align:center ! important; font-weight:bold; }
	.P4 { font-size:12pt; font-family:Times New Roman; writing-mode:page; font-weight:bold; }
	.P5 { font-size:12pt; font-family:Times New Roman; writing-mode:page; font-style:italic; }
	.P6 { font-size:12pt; font-family:Times New Roman; writing-mode:page; text-decoration:underline; }
	.P7 { font-size:12pt; font-family:Times New Roman; writing-mode:page; text-align:center ! important; }
	.P8 { font-size:12pt; font-family:Times New Roman; writing-mode:page; font-weight:normal; }
	.P9 { font-size:12pt; font-family:Times New Roman; writing-mode:page; font-weight:normal; }
	.Standard { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.Internet_20_link { color:#000080; text-decoration:underline; }
	.T1 { font-weight:bold; }
	.T2 { font-size:10pt; }
	<!-- ODF styles with no properties representable as CSS -->
	{ }
	</style></head><body dir="ltr" style="max-width:21.001cm;margin-top:2cm; margin-bottom:2cm; margin-left:2cm; margin-right:2cm; "><p class="P3">I2C zu RS232 / USB Interface</p><p class="P7"> </p><p class="P10">Author DK1RI, Version V03.1, 20151223</p><p class="P10">This project can be found in github.com/dk1ri</p><p class="P4"> </p><p class="P4">Einleitung</p><p class="Standard"> </p><p class="Standard">Diese beiden Interfaces sollen im wesentlichen zum Test von MYC Devices und für Softwaretests dienen.</p><p class="Standard">Mit einem Interface als Master und einem als Slave können die Grundfunktionen eines MYC Systems demonstriert werden.</p><p class="Standard">Das Interface als Master ist auch als RS232 - I2C Konverter verwendbar.</p><p class="Standard">Das Interface als Slave kann als Prototyp für andere Interfaces mit RS232 Device-Schnittstelle verwendet werden.</p><p class="Standard"> </p><p class="P4">Beschreibung</p><p class="Standard"> </p><p class="Standard">Es gibt eine Softwareversion als I2C Master und eine als Slave.</p><p class="Standard">Die Eagle Daten für die Leiterplatte stehen unter  [1].</p><p class="Standard">Die Stromversorgung ist 7- 10V, Stromaufnahme ca. 40mA max.</p><p class="Standard">Als Testinterface wird an der RS232 Schnittstelle (19,2kB, 8N1) oder an der USB Schnittstelle ein Rechner mit Terminalprogramm angeschlossen .</p><p class="P4"> </p><p class="P4">Einbindung in das MYC System</p><p class="Standard"> </p><p class="Standard">Details zum MYC System stehen in [3].</p><p class="Standard">Dieses Interface kann als I2C Master für die Bedienung eines MYC Devices ohne command-router verwendet werden.</p><p class="Standard">Wenn dann das gleiche Interface als Slave angeschlossen wird, arbeitet das Master Interface (fast) wie ein command-router mit einer RS232 Schnittstelle für eine Benutzerschnittstelle oder übergeordnetes MYC System. Auf der RS232 Seite  werden die MYC commands eingeben, so wie die Benutzerschnittstelle das tun muss.</p><p class="Standard">Nimmt das Interface auf der Befehlsschnittstelle (I2C beim Slave, RS232 beim Master) Daten entgegen und interpretiert das erste Zeichen als Befehl und handelt entsprechend. Wird ein Befehl oder Parameter als ungültig erkannt, wird das nächste Zeichen als neuer Befehl interpretiert.</p><p class="Standard">Der Befehl wird ausgeführt, wenn er mit Parametern komplett erkannt wurde.</p><p class="Standard">Ein nicht vollständiger Befehl wird nach ca 0,5 s gelöscht.</p><p class="Standard">Die Strings müssen mit der Zahl der Bytes beginnen!</p><p class="Standard"> </p><p class="P5">I2C als Slave :</p><p class="Standard"> </p><p class="Standard">Dieses Interface ist ein einfaches Device mit (neben den reservierten Befehlen) nur 2 Befehlen an der I2 Schnittstelle: der Schreibbefehl gibt den von der I2C Schnittstelle empfangenen String auf die RS232 Schnittstelle. Der Lesebefehl kopiert die Daten des RS232 Eingabepuffers in den I2C Puffer, wo der I2C Master die Daten abholen kann.</p><p class="Standard">Eingaben auf der RS232 Schnittstelle werden nicht geechot und nur in der RS232 Puffer kopiert. Wenn kein Lesebefehl erfolgt, werden nach 252 Zeichen weitere Zeichen ignoriert.</p><p class="Standard"> </p><p class="Standard"> </p><p class="Standard"> </p><p class="P11">Folgende Befehle werden von der I2C Schnittstelle akzeptiert:</p><p class="Standard">Befehl <span> </span><span> Parameter</span></p><p class="Standard">'</p><p class="Standard">Announce0:</p><p class="Standard">'Befehl &amp;H00               basic annoumement wird gelesen</p><p class="Standard">'                          basic announcement is read to I2C</p><p class="Standard">Data "0;m;DK1RI;Rs232_i2c_interface Slave;V03.1;1;170;3;8"</p><p class="Standard">'</p><p class="Standard">Announce1:</p><p class="Standard">'Befehl &amp;H01 &lt;s&gt;           Sendet Daten von I2C nach RS232</p><p class="Standard">'                          read data from I2C, write to RS232 (write to device)</p><p class="Standard">Data "1;oa;252"</p><p class="Standard">'</p><p class="Standard">Announce2:</p><p class="Standard">'Befehl &amp;H02               liest Daten von RS232 nach I2C</p><p class="Standard">'                          read data from RS232, write to I2C  (read from device)</p><p class="Standard">Data "2;aa,as1"</p><p class="Standard">'</p><p class="Standard">Announce3:</p><p class="Standard">'Befehl &amp;HF0 0-13,</p><p class="Standard">'            253,254 255   announcement aller Befehle lesen</p><p class="Standard">'                          read announcement lines</p><p class="Standard">Data "240;am,ANNOUNCEMENTS;170;8"</p><p class="Standard">'</p><p class="Standard">Announce4:                                                  '</p><p class="Standard">'Befehl &amp;HFC               Liest letzten Fehler</p><p class="Standard">'                          read last error</p><p class="Standard">Data "252;aa,LAST ERROR;20,last_error"</p><p class="Standard">'</p><p class="Standard">Announce5:                                                  '</p><p class="Standard">'Befehl &amp;HFD               geraet aktiv antwort</p><p class="Standard">'                          Life signal</p><p class="Standard">Data "253;af,MYC INFO;b,&amp;H04,BUSY"</p><p class="Standard">'</p><p class="Standard">Announce6:</p><p class="Standard">'Befehl &amp;HFE &lt;n&gt; &lt;n&gt;       Individualisierung schreiben</p><p class="Standard">'                          write indivdualization</p><p class="Standard">Data "254;oa,INDIVIDUALIZATION;20,NAME,Device 1;b,NUMBER,1;1,I2C,1;b,ADRESS,1"</p><p class="Standard">'</p><p class="Standard">Announce7:</p><p class="Standard">Data "255;aa,INDIVIDUALIZATION;20,NAME,Device 1;b,NUMBER,1;1,I2C,1;b,ADRESS,1;1,RS232,1;b,BAUDRATE,0,{19200};3,NUMBER_OF_BITS,8n1;1,USB,1"</p><p class="Standard">'</p><p class="Standard"> </p><p class="Standard">Beispiele im HEX Format:</p><p class="Standard"> </p><p class="Standard">010474657374<span> </span><span> (01 ist der Befehl des Slave zur Ausgabe auf der RS232 Schnittstelle)</span></p><p class="Standard">gibt 4 Zeichen des Strings „test“ mit CRLF auf der seriellen Schnittstelle aus.</p><p class="Standard">Ist die Länge größer als 252 Byte oder werden mehr Zeichen übertragen als in der Länge angegeben, wird der Rest alsverworfen.</p><p class="Standard">Dieses Interface kann ein Prototyp für ein Interface für Geräte mit RS232 Schnittstelle sein. Als Interface für andere Geräte muss das Interface andere / weitere Befehlskonvertierungen machen.</p><p class="Standard"> </p><p class="P5">I2C als  Master:</p><p class="Standard"> </p><p class="Standard">Normalerweise ist in einem MYC System an einem I2C Bus der Command-router der Master. Das Interface soll also einen manuell bedienbaren command-router emulieren. </p><p class="Standard">Ein richtiger commandrouter kennt die Befehle des angeschlossenen Devices und die Adresse (bei I2C). Das Interface hat daher zwei Betriebsarten:</p><p class="Standard">- für den Anschluss eines gleichen Interfaces als Slave, Myc_mode = 1</p><p class="Standard">- für den Anschluss beliebiger (MYC -) Devices oder als Protokollwandler, Myc_mode = 0 (default)</p><p class="Standard">Einige Befehle funktionieren nur abhängig vom gewählten Myc_mode.</p><p class="Standard"> </p><p class="Standard">Folgende Befehle werden von der RS232 Schnittelle akzeptiert:</p><p class="Standard">Befehl <span> </span><span> Parameter</span></p><p class="Standard">'</p><p class="Standard">Announce0:</p><p class="Standard">'Befehl &amp;H00               basic annoumement wird gelesen</p><p class="Standard">'                          basic announcement is read</p><p class="Standard">Data "0;m;DK1RI;RS232_I2C_interface Master;V03.1;1;170;15;20"</p><p class="Standard">'</p><p class="Standard">Announce1:</p><p class="Standard">'Befehl &amp;H01 &lt;s&gt;           string an angeschlossenes device schicken Myc_mode = 0</p><p class="Standard">'                          write string to device</p><p class="Standard">Data "1;oa;253"</p><p class="Standard">'</p><p class="Standard">Announce2:</p><p class="Standard">'Befehl &amp;H02 &lt;s&gt;           string von angeschlossenem device lesen, Myc_mode = 0</p><p class="Standard">'                          read string from device</p><p class="Standard">Data "2;aa,as1"</p><p class="Standard">'</p><p class="Standard">Announce3:</p><p class="Standard">'Befehl &amp;H10               übersetzes 0 des slave Myc_mode = 1</p><p class="Standard">'                          translated 0 of slave</p><p class="Standard">Data "16;m;DK1RI;RS232_I2C_interface Slave;V01.1.4;1;170;8;13"</p><p class="Standard">'</p><p class="Standard">Announce4:</p><p class="Standard">'Befehl &amp;H11 &lt;s&gt;           übersetzes 1 des slave Myc_mode = 1 I2C nach RS232</p><p class="Standard">'                          translated 1 of slave I2C to RS232</p><p class="Standard">Data "17,oa;252"</p><p class="Standard">'</p><p class="Standard">Announce5:</p><p class="Standard">'Befehl &amp;H12               übersetzes 2 des slave Myc_mode = 1 , RS232 nach I2C</p><p class="Standard">'                          translated 2 of slave, RS232 to I2C</p><p class="Standard">Data "18,aa,as17"</p><p class="Standard">'</p><p class="Standard">Announce6:</p><p class="Standard">'Befehl &amp;H13 &lt;n&gt;           übersetzes 240 des slave Myc_mode = 1 , Daten sind lokal wie bei einem commandrouter gespreichert</p><p class="Standard">'                          translated 240 of slave,</p><p class="Standard">Data "19;am,ANNOUNCEMENTS;170;8"</p><p class="Standard">'</p><p class="Standard">Announce7:</p><p class="Standard">'Befehl &amp;H14               übersetzes 252 des slave Myc_mode = 1</p><p class="Standard">'                          translated 252 of slave,</p><p class="Standard">Data "20;aa,LAST ERROR;20,last_error"</p><p class="Standard">'</p><p class="Standard">Announce8:</p><p class="Standard">'Befehl &amp;H15               übersetzes 253 des slave Myc_mode = 1</p><p class="Standard">'                          translated 253 of slave,</p><p class="Standard">Data "21;af,MYC INFO;b,&amp;H04"</p><p class="Standard">'</p><p class="Standard">Announce9:</p><p class="Standard">'Befehl &amp;H16 &lt;n&gt; &lt;n&gt;       übersetzes 254 des slave Myc_mode = 1</p><p class="Standard">'                          translated 254 of slave,</p><p class="Standard">Data "22;oa,INDIVIDUALIZATION;20,NAME,Device 1;b,NUMBER,1;1,I2C,1;b,ADRESS,1"</p><p class="Standard">'</p><p class="Standard">Announce10:</p><p class="Standard">'Befehl &amp;H17 &lt;n&gt;           übersetzes 255 des slave Myc_mode = 1</p><p class="Standard">'                          translated 255 of slave,</p><p class="Standard">Data "23;aa,as22"</p><p class="Standard">'</p><p class="Standard">Announce11:</p><p class="Standard">'Befehl &amp;HEE 0|1           MYC_mode speichern</p><p class="Standard">'                          write myc_mod</p><p class="Standard">Data "238;oa;a"</p><p class="Standard">'</p><p class="Standard">Announce12:</p><p class="Standard">'Befehl &amp;HEF               MYC_mode lesen</p><p class="Standard">'                          read myc_mod</p><p class="Standard">Data "239;aa,as238"</p><p class="Standard">'</p><p class="Standard">Announce13:</p><p class="Standard">'Befehl &amp;HF0 0-13,</p><p class="Standard">'            253,254 255   announcement aller Befehle lesen</p><p class="Standard">'                          read announcement lines</p><p class="Standard">Data "240;am,ANNOUNCEMENTS;170;20"</p><p class="Standard">'</p><p class="Standard">Announce14:                                                 '</p><p class="Standard">'Befehl &amp;HFC               Liest letzten Fehler</p><p class="Standard">'                          read last error</p><p class="Standard">Data "252;aa,LAST ERROR;20,last_error"</p><p class="Standard">'</p><p class="Standard">Announce15:                                                 '</p><p class="Standard">'Befehl &amp;HFD               geraet aktiv antwort</p><p class="Standard">'                          Life signal</p><p class="Standard">Data "253;aa,MYC INFO;b,&amp;H04,BUSY"</p><p class="Standard">'</p><p class="Standard">Announce16:</p><p class="Standard">'Befehl &amp;HFE &lt;n&gt; &lt;n&gt;       Individualisierung schreiben</p><p class="Standard">'                          write indivdualization</p><p class="Standard">Data "254;oa,INDIVIDUALIZATION;20,NAME,Device 1;b,NUMBER,1;1,I2C,1;b,ADRESS,1"</p><p class="Standard">'</p><p class="Standard">Announce17:</p><p class="Standard">Data "255;aa,INDIVIDUALIZATION;20,NAME,Device 1;b,NUMBER,1;1,I2C,1;b,ADRESS,0;1,RS232,1;b,BAUDRATE,0,{19200};3,NUMBER_OF_BITS,8n1;1,USB,1"</p><p class="Standard">Announce18:</p><p class="Standard">Data "R !($1 $2) IF $238=1"</p><p class="Standard">Announce19:</p><p class="Standard">Data "R !($10 $11 $12 $13 $14 $15 $16 $17) IF $238=0"</p><p class="Standard">'</p><p class="Standard"> </p><p class="P6">Anschluss eines gleichen Slave-Interfaces, der Master ist "commandrouter"</p><p class="P6"> </p><p class="Standard">Dieser Mode wird durch den Befehl &amp;HEE01 eingestellt. Die Befehle &amp;H01 ,&amp;H02 gelten nicht.</p><p class="Standard">Dann verhält das Interface wie ein command-router und setzt die Befehle für das Slave Interface  richtig um.</p><p class="Standard"> </p><p class="Standard">Die Eingabe and der RS232 Schnittstelle hat ein Echo. (ein command-router allerdings nicht)</p><p class="Standard">Die Ausgabe erfolgt ohne Abschluss (CR LF)</p><p class="Standard">An der RS232 Schnittstelle müssen alle Werte als Bytewerte ( ein Byte von 0 bis 255) eingegeben werden!!. Es erfolgt keine Umwandlung (zB vom Hex auf Binär). Eingabe auf der Windows Tastatur mit &lt;ALT&gt; und 3 Ziffern des ASCII Codes. Einfacher ist es, wenn das Terminalprogramm die Eingabe in Hexformat zulässt.</p><p class="Standard"> </p><p class="Standard">Bei den folgenden Beispielen werden zwei gleiche Interfaces angenommen; eins als Master und eins als Slave konfiguriert.</p><p class="Standard">Entsprechend den MYC Regeln  lautet ein Schreibbefehl zum Beispiel (gezeigt im  HEX Format):</p><p class="Standard">110474657374</p><p class="Standard">11 ist der Befehl an das Master-Interface zum Schreiben, der auf den I2CBus als Befehl 01 weitergegeben wird,</p><p class="Standard">Die 04 ist die Länge des folgenden Strings. Danach folgt der zu übertragende Text (test).</p><p class="Standard">Bei dem gleichen Interface als Slave wird der Text -test- auf der RS232 Schnittstelle ausgegeben.</p><p class="Standard">Ein Lesebefehl (ebenso im HEX Format)</p><p class="Standard">12</p><p class="Standard">12 ist der Befehl zum Lesen. Der Befehl (weitergegeben als 02) bewirkt beim Slave, dass der String im Eingabepuffer mit vorangestellter Länge des String in den Ausgabepuffer geschrieben wird. Danach liest der Master den String und gibt ihn an die RS232 Schnittstelle. Wurden auf der Slave Seite keine Daten eingegeben, wird nur die Länge (0) ausgegeben.</p><p class="Standard">Die angegebene Länge (253) im announcement ist die Maximallänge des String, die der Master behandeln kann..</p><p class="Standard">Der Befehl</p><p class="Standard">10</p><p class="Standard">liefert das basic announcement des Slave. Die Daten liefert der Master, ohne den Slave zu fragen; so wie es der command-router machen würde.</p><p class="P6">Anschluss eines beliebigen Devices:</p><p class="P6"> </p><p class="Standard">Dieser Mode wird durch &amp;HEE00 eingestellt und ist der Default Mode. Die Befehle &amp;H10 - &amp;H17 gelten nicht.</p><p class="Standard">Dann erfolgt keine Umsetzung der Befehle und bei Befehlen an den Slave, die Daten zurückgeben, Es muss der Lesebefehl geschickt werden.</p><p class="Standard"> </p><p class="Standard">Beispiel zum Senden &amp;H01</p><p class="Standard">0106010474657374</p><p class="Standard">Nach dem Befehl 01 beginnt der Sendestring mit der Länge des folgenden String (06). Das folgende (dritte) Zeichen kann der Befehlstoken an ein angeschlossenes Device sein.01 gibt folgenden String der Länge 04 am i2c‑&gt;RS232 Interface aus: test</p><p class="Standard">Bei gleichem Interface als Slave muss der Lesebefehl 02 (Länge 1) mit </p><p class="Standard">010102 gesendet werden. Dieser Befehl kopiert den RS232 Puffer in den I2C Puffer. Danach werden zum Beispiel 5 Byte gelesen:</p><p class="Standard">0205</p><p class="Standard">Das erste empfangene Byte ist dabei Länge,  da bei diesem Befehl ein String folgt !!!</p><p class="Standard">Andere Befehle geben ggf andere Datentypen zurück. </p><p class="Standard">Im Gegensatz zum Mode mit angeschlossenem Interface ist ja nicht bekannt, ob der Befehl eine Antwort hat. Die Antwort muss daher extra mit dem Lesebefehl geholt werden.</p><p class="Standard">Da auch der Typ und die Länge der Antwort nicht bekannt ist, muss beim Lesen die Länge des zu lesenden String angegeben werden.</p><p class="Standard">Die I2C Adresse des Slave kann mit &amp;HFE03xx eingegeben werden. Die Adresse xx muss geradzahlig sein (die Adresse 04 muss als 08 eingegeben werden).</p><p class="Standard"> </p><p class="P4">Regeln</p><p class="Standard"> </p><p class="Standard">Es gibt zwei Zeilen mit Regeln  für den Master , da abhängig vom Myc_mode einige Befehle nicht funktionieren.</p><p class="Standard"> </p><p class="P4">I2C Adresse</p><p class="Standard"> </p><p class="Standard">Die Default Adresse ist 1  für den Slave.</p><p class="Standard">Mit dem Befehl &amp;HFE03&lt;n&gt; kann die Adresse in n (1 … 128) geändert werden.</p><p class="Standard">Beim Master ist das die Adresse, zu der geschrieben /gelesen wird  (default 1)!!!</p><p class="Standard">Pullup Widerstände für den I2C Bus (R8/R9) können bei Bedarf bestückt werden. Der Gesamtwiderstand am Bus sollte zwischen 1 und 10 kOhm liegen. </p><p class="Standard"> </p><p class="P4">Fehlermeldungen</p><p class="P4"> </p><p class="Standard">Der Befehl &amp;HFC liefert den letzten Fehler im Format:</p><p class="Standard">aktuelle Befehlsnummer - Fehler - Befehlsnummer beim Auftritt des Fehlers</p><p class="Standard">Dazu werden die empfangenen Befehle von 0 bis 255 umlaufend gezählt.</p><p class="Standard"> </p><p class="P4">Reset</p><p class="P4"> </p><p class="Standard">Ist der Reset Jumper JP4 beim Anlegen der Versorgungsspannung überbrückt, werden wieder die Defaultwerte eingelesen. Dies ist hilfreich, wenn die aktuelle I2C Adresse verloren gegangen ist.</p><p class="Standard"> </p><p class="Standard"> </p><p class="P4">Watchdog</p><p class="Standard"> </p><p class="Standard">Die Befehlseingabe muss in weniger als 1 Sekunde beendet sein. Danach werden die bereits empfangenen Daten gelöscht. Dies soll falsche Eingaben vermeiden.  Mit dem "letzten Fehler" Befehl kann man Eingabefehler sehen. Er zeigt die aktuelle Befehlsnummer und die des Fehlers.</p><p class="Standard">Nach jedem beendeten Befehl wird der gesamte Befehlspuffer gelöscht</p><p class="Standard"> </p><p class="P4">Software</p><p class="P4"> </p><p class="Standard">Die Steuerung übernimmt ein AVR Mikrocontroller Atmega8 oder größer</p><p class="Standard">Die Software wurde in BASCOM geschrieben [2]</p><p class="Standard"> </p><p class="P4">Programmierung des Prozessors</p><p class="Standard"> </p><p class="Standard">Zur Programmierung des Prozessors ist ein 6poliger ISP Stecker vorhanden.</p><p class="Standard">Um der Prozessor von der Stromversorgung der übrigen Schaltung zu trennen, muss der Jumper JP1 entfernt werden.</p><p class="P10">Die Fuses müssen möglicherweise programmiert werden (sh Bascom Programm) !! Prozessortyp und Frequenz müssen ggf angepasst werden.</p><p class="P4"> </p><p class="P4">RS232 Schnittstelle</p><p class="Standard"> </p><p class="Standard">Schnittstellenparameter: 19k2 8N1</p><p class="Standard">Es muss bei Jumper JP7 und JP8 ist jeweils Pin1 und Pin2  überbrückt werden.</p><p class="Standard"> </p><p class="P4">USB Schnittstelle</p><p class="Standard"> </p><p class="Standard">Das Interface kann alternativ mit der USB Platine UM2102 von ELV bestückt werden. Die USB Platine wird plan auf der Oberseite der Interfaces verlötet: der USB Stecker zeigt seitlich nach außen. Die mittleren 4 pins des Verbinders ST2  sind mit dem 4 poligen Verbinder JP9 auf dem Interface zu verbinden.USB Platine und Interface müssen voneinander isoliert werden.</p><p class="Standard">Die Stromversorgung erfolgt dann über USB.</p><p class="Standard"> </p><p class="P4">SMD</p><p class="Standard"> </p><p class="Standard">Die Leiterplatte ist teilweise mit SMD bestückt. Bei den nötigen Bauteilen sind das aber nur relativ großen Kondensatoren (1206).</p><p class="Standard">Es gibt einen nicht getesteten Leiterplattenentwurf für eine recht kleine Leiterplatte mit Minimalbestückung und TQFP Prozessor [4] Die muss mit dem ELV USB Modul bestückt werden.</p><p class="Standard"> </p><p class="P4">Stromversorgung</p><p class="Standard"> </p><p class="Standard">Die Stromversorgung ist 7- 15V, Stromaufnahme ca. 40mA max. Bei Verwendung des USB Moduls erfolgt die Stromversorgung darüber.</p><p class="Standard"> </p><p class="P4">Bestückung der Leiterplatte</p><p class="Standard"> </p><p class="Standard">Da die Leiterplatte auch für andere Anwendungen eingesetzt werden kann, brauchen nur folgende Bauteile  bestückt werden:</p><p class="Standard">IC1, Q1, C3 – C6, X2, X3, JP1 (muss für Normalbetrieb überbrückt werden), </p><p class="Standard"> </p><p class="Standard">mit RS232 Schnittstelle:</p><p class="Standard">IC2, IC3, D1, C1, C2, C7 – C10, JP7, JP8 (jeweils Pin1 und Pin 2 überbrücken), X1, X4 (Buchse)</p><p class="Standard"/><p class="Standard"> </p><p class="Standard">Verwendung von ISP:</p><p class="Standard">JP6</p><p class="Standard"> </p><p class="Standard">I2C Pullups nach Bedarf:</p><p class="Standard">R8, R9</p><p class="Standard">Weitere Bestückung erleichtert Tests..</p><p class="Standard"> </p><p class="Standard"><span class="T1">Anschlüss</span>e</p><p class="Standard"> </p><p class="Standard">Power</p><p class="Standard">Tip<span> 12V</span></p><p class="Standard">Ring<span> GND</span></p><p class="Standard"> </p><p class="Standard">RS232 (Buchse)</p><p class="Standard">5<span> GND</span></p><p class="Standard">2<span> Jumper</span></p><p class="Standard">3<span> Jumper</span></p><p class="Standard"> </p><p class="Standard">I2C Stereo (2 x 3,5mm Klinke)</p><p class="Standard">Sleeve<span> GND</span></p><p class="Standard">Ring<span> SDA</span></p><p class="Standard">Tip<span> SCL</span></p><p class="P4"> </p><p class="P4">Versionen</p><p class="Standard"> </p><p class="Standard">Diese Beschreibung gilt für die</p><p class="Standard">Leiterplattenversion V02.0</p><p class="Standard">Bascom Version V03.1 für Master und Slave</p><p class="Standard"> </p><p class="P4">Copyright</p><p class="P8"> </p><p class="P9">Die Ideen in diesem Dokument unterliegen der GPL (Gnu Public Licence) soweit keine früheren, anderen Rechte betroffen sind.</p><p class="P9">Die Verwendung der Unterlagen erfolgt auf eigene Geafahr; es wird keinerlei Garantie übernommen.</p><p class="P9">The ideas of this document can be used under GPL (Gnu Public License) as long as no earlier other rights are affected.</p><p class="P9">The usage of this document is on own risk, there is no warranty.</p><p class="P9"> </p><p class="P4">Referenzen</p><p class="Standard"> </p><p class="Standard">[1]<span> <a href="http://www.dk1ri.de/common/myc/MYC_i2c_rs232_interface/i2c_rs232_interface_eagle.zip" class="Internet_20_link"><span class="T2">i2c_rs232_interface_eagle.zip</span></a></span></p><p class="Standard">[2]<span> <a href="http://www.dk1ri.de/common/myc/MYC_i2c_rs232_interface/i2c_rs232_interface_bascom.zip" class="Internet_20_link"><span class="T2">i2c_rs232_interface_bascom.zip</span></a></span></p><p class="Standard">[3]<span> <a href="http://www.dk1ri.de/common/myc/MYC_basic/MYC.pdf" class="Internet_20_link">MYC.pdf</a></span></p><p class="Standard">[4]<span> <a href="http://www.dk1ri.de/common/myc/MYC_i2c_rs232_interface/i2c_rs232_interface_eagle_31.zip" class="Internet_20_link"><span class="T2">Minimal_i2c_USB_interface_eagle.zip</span></a></span></p></body></html>